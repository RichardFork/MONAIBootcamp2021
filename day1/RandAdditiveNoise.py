import monai
import torch
import numpy as np
from monai.config import KeysCollection
from monai.transforms import (Transform, Randomizable, MapTransform)
from typing import Optional, Any, Mapping, Hashable

class RandAdditiveNoise(Randomizable, Transform):
    def __init__(self, prob: float = 0.5, max_add: float = 1.0) -> None:
        self.prob = np.clip(prob, 0.0, 1.0)
        self.max_add = max_add
        self._noise = 0

    # def randomize(self, data: np.ndarray) -> None:
    #     self._noise = 0
    #
    #     if self.R.random() < self.prob:
    #         noise_array = self.R.rand(*data.shape[1:])[None]
    #         self._noise = (noise_array * self.max_add).astype(data.dtype)

    def randomize(self, data):
        # data가 torch.Tensor인 경우 numpy로 변환
        if isinstance(data, torch.Tensor):
            data = data.numpy()

        noise_array = self.R.rand(*data.shape[1:])[None]
        self._noise = (noise_array * self.max_add).astype(data.dtype)

    def add_noise(self, img: np.ndarray) -> np.ndarray:
        return img + self._noise

    def __call__(self, img: np.ndarray) -> np.ndarray:
        self.randomize(img)
        return self.add_noise(img)

class RandAdditiveNoised(Randomizable, MapTransform):
    def __init__(
        self, keys: KeysCollection, prob: float = 0.5, max_add: float = 1.0
    ) -> None:
        super(Randomizable, self).__init__(keys)
        self.transform = RandAdditiveNoise(prob, max_add)

    def set_random_state(
        self, seed: Optional[int] = None, state: Optional[np.random.RandomState] = None
    ) -> "RandAdditiveNoised":
        self.transform.set_random_state(seed, state)
        super().set_random_state(seed, state)
        return self

    def randomize(self, data: Optional[Any] = None) -> None:
        self.transform.randomize(data)

    def __call__(
        self, data: Mapping[Hashable, np.ndarray]
    ) -> Mapping[Hashable, np.ndarray]:
        self.randomize(data[monai.utils.first(self.keys)])

        d = dict(data)
        for key in self.keys:
            d[key] = self.transform.add_noise(d[key])
        return d